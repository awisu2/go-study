# context

- [context package \- context \- pkg\.go\.dev](https://pkg.go.dev/context)

**NOTE**

- context can Cancel and set Deadline. when there ran `context.Done()` return true
  - in the goroutine can catch `context.Done()`. typically use close goroutine.
- context's `WithCancel`, `WithDeadline()` create child copy
- when content run Cancel or Deadline. enable `context.Done()` current instance and children.
- define context: `context.Background()`
  - when we use `context.TODO()`?: 通常 context は自身や、WithCancel()などで生成した子インスタンスのチェイン構造を守るため、関数などでインスタンスを引き回しますが、状況によってはその準備ができていない/そもそも用意されていないことがあります。そんな場合に TODO()を利用します。これはまだ準備中っていうことですね
  - Normally, context is routed by a function etc. in order to protect the chain structure of the child instance generated by itself or WithCancel () etc., but depending on the situation, it may not be ready / prepared in the first place. In such a case, use TODO (). This is still in preparation (just google translate)
- notice
  - The context cannot be saved in a persistent location as it can be deleted after use.
  - Not set in struct instance
  - Not set non clear variables(like global, static... etc)

## sample

- When declared with `WithCancel()`, the names are different, but usually the same name (`ctx`) to maintain the parent-child relationship.

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func contextDone(runCancel2 bool) {
	ctx := context.Background()
	ctxCancel1, cancel1 := context.WithCancel(ctx)
	ctxCancel2, cancel2 := context.WithCancel(ctxCancel1)
	defer func() {
		cancel1()
		cancel2()
	}()

	runGoroutine := func() <- chan int {
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select{
				case <- ctx.Done():
					fmt.Println("done base") // not run this
				case <- ctxCancel1.Done():
					fmt.Println("done cancel1")
				case <- ctxCancel2.Done():
					fmt.Println("done cancel2")
					return
				case dst <- n:
					n++
				}
			}
		}()
		return dst
	}

	for range runGoroutine() {
		if runCancel2 {
			cancel2()
		} else {
			cancel1()
		}
		break
	}

	// for check ctx.Done()'s print
	time.Sleep(1 * time.Second)
}

func main() {
	fmt.Println("run cancel 1 ---------")
	contextDone(false)
	// done cancel1
	// done cancel1
	// ...
	// done cancel2

	fmt.Println("run cancel 2 ---------")
	contextDone(true)
	// done cancel2
}
```
